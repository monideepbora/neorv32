<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The NEORV32 RISC-V Processor - Software Framework: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="neorv32_logo_transparent_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The NEORV32 RISC-V Processor - Software Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/stnolting/neorv32"><img src="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/figures/neorv32_logo_dark.png" alt="NEORV32" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
The NEORV32 RISC-V Processor</h1>
<p><a href="https://github.com/stnolting/neorv32/actions?query=workflow%3A%22Processor+Check%22"><img src="https://github.com/stnolting/neorv32/workflows/Processor%20Check/badge.svg" alt="Processor Check" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/stnolting/neorv32/actions/workflows/riscv-arch-test.yml"><img src="https://github.com/stnolting/neorv32/actions/workflows/riscv-arch-test.yml/badge.svg" alt="riscv-arch-test" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/stnolting/neorv32/blob/master/LICENSE"><img src="https://img.shields.io/github/license/stnolting/neorv32" alt="license" class="inline"/></a> <a href="https://github.com/stnolting/neorv32/releases"><img src="https://img.shields.io/github/v/release/stnolting/neorv32" alt="release" class="inline"/></a></p>
<ul>
<li><a href="#Overview">Overview</a></li>
<li><a href="#Status">Status</a></li>
<li><a href="#Features">Features</a></li>
<li><a href="#FPGA-Implementation-Results">FPGA Implementation Results</a></li>
<li><a href="#Performance">Performance</a></li>
<li><a href="#Top-Entities">Top Entities</a></li>
<li><a href="#Getting-Started"><b>Getting Started</b></a></li>
<li><a href="#ContributeFeedbackQuestions">Contribute/Feedback/Questions</a></li>
<li><a href="#Legal">Legal</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md1"></a>
Overview</h2>
<p>The NEORV32 Processor is a customizable microcontroller-like system on chip (SoC) that is based on the RISC-V NEORV32 CPU. The processor is intended as <em>ready-to-go</em> auxiliary processor within a larger SoC designs or as stand-alone custom microcontroller.</p>
<p>:books: For detailed information take a look at the <a href="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/NEORV32.pdf">NEORV32 data sheet (pdf)</a>. The doxygen-based documentation of the <em>software framework</em> is available online at <a href="https://stnolting.github.io/neorv32/files.html">GitHub-pages</a>.</p>
<p>:label: The project’s change log is available as <a href="https://github.com/stnolting/neorv32/blob/master/CHANGELOG.md">CHANGELOG.md</a> in the root directory of this repository. To see the changes between <em>stable</em> releases visit the project's <a href="https://github.com/stnolting/neorv32/releases">release page</a>.</p>
<p>:spiral_notepad: Check out the <a href="https://github.com/stnolting/neorv32/projects">project boards</a> for a list of current <b>ideas</b>, <b>TODOs</b>, features being <b>planned</b> and <b>work-in-progress</b>.</p>
<p>:bulb: Feel free to open a <a href="https://github.com/stnolting/neorv32/issues">new issue</a> or start a <a href="https://github.com/stnolting/neorv32/discussions">new discussion</a> if you have questions, comments, ideas or bug-fixes. Check out how to <a href="#ContributeFeedbackQuestions">contribute</a>.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Key Features</h3>
<ul>
<li>RISC-V 32-bit <code>rv32</code> <a href="#NEORV32-CPU-Features"><b>NEORV32 CPU</b></a>, compatible to<ul>
<li>subset of the <em>Unprivileged ISA Specification</em> <a href="https://github.com/stnolting/neorv32/blob/master/docs/riscv-spec.pdf">(Version 2.2)</a></li>
<li>subset of the <em>Privileged Architecture Specification</em> <a href="https://github.com/stnolting/neorv32/blob/master/docs/riscv-privileged.pdf">(Version 1.12-draft)</a></li>
<li>the <a href="#Status">official RISC-V architecture tests</a> (<em>passing</em>)</li>
</ul>
</li>
<li>Configurable RISC-V-compatible CPU extensions<ul>
<li><a href="#A---Atomic-memory-access-extension"><code>A</code></a> - atomic memory access instructions (optional)</li>
<li><a href="#B---Bit-manipulation-instructions-extension"><code>B</code></a> - Bit manipulation instructions (optional) :construction:</li>
<li><a href="#C---Compressed-instructions-extension"><code>C</code></a> - compressed instructions (16-bit) (optional)</li>
<li><a href="#E---Embedded-CPU-version-extension"><code>E</code></a> - embedded CPU (reduced register file size) (optional)</li>
<li><a href="#I---Base-integer-instruction-set"><code>I</code></a> - base integer instruction set (always enabled)</li>
<li><a href="#M---Integer-multiplication-and-division-hardware-extension"><code>M</code></a> - integer multiplication and division hardware (optional)</li>
<li><a href="#U---Privileged-architecture---User-mode-extension"><code>U</code></a> - less-privileged <em>user mode</em> (optional)</li>
<li><a href="#X---NEORV32-specific-CPU-extensions"><code>X</code></a> - NEORV32-specific extensions (always enabled)</li>
<li><a href="#Zicsr---Privileged-architecture---CSR-access-extension"><code>Zicsr</code></a> - control and status register access instructions (+ exception/irq system) (optional)</li>
<li><a href="#Zifencei---Privileged-architecture---Instruction-stream-synchronization-extension"><code>Zifencei</code></a> - instruction stream synchronization (optional)</li>
<li><a href="#PMP---Privileged-architecture---Physical-memory-protection"><code>PMP</code></a> - physical memory protection (optional)</li>
<li><a href="#HPM---Privileged-architecture---Hardware-performance-monitors"><code>HPM</code></a> - hardware performance monitors (optional)</li>
</ul>
</li>
<li>Full-scale RISC-V microcontroller system / <b>SoC</b> <a href="#NEORV32-Processor-Features"><b>NEORV32 Processor</b></a> with optional submodules<ul>
<li>optional embedded memories (instructions/data/bootloader, RAM/ROM) and caches</li>
<li>timers (watch dog, RISC-V-compatible machine timer)</li>
<li>serial interfaces (SPI, TWI, UARTs)</li>
<li>general purpose IO and PWM channels</li>
<li>external bus interface (Wishbone / <a href="#AXI4-Connectivity">AXI4</a>)</li>
<li>subsystem for custom co-processors</li>
<li><a href="#NEORV32-Processor-Features">more ...</a></li>
</ul>
</li>
<li>Software framework<ul>
<li>core libraries for high-level usage of the provided functions and peripherals</li>
<li>application compilation based on <a href="https://github.com/stnolting/neorv32/blob/master/sw/example/blink_led/makefile">GNU makefiles</a></li>
<li>GCC-based toolchain (<a href="https://github.com/stnolting/riscv-gcc-prebuilt">pre-compiled toolchains available</a>)</li>
<li>bootloader with UART interface console</li>
<li>runtime environment</li>
<li>several example programs</li>
<li><a href="https://github.com/stnolting/neorv32/blob/master/docs/doxygen_makefile_sw">doxygen-based</a> software documentation: available on <a href="https://stnolting.github.io/neorv32/files.html">GitHub pages</a></li>
<li><a href="https://github.com/stnolting/neorv32/blob/master/sw/example/demo_freeRTOS">FreeRTOS port</a> available</li>
</ul>
</li>
<li><a href="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/NEORV32.pdf"><b>Full-blown data sheet</b></a> (pdf)</li>
<li>Completely described in behavioral, platform-independent VHDL - no primitives, macros, etc.</li>
<li>Fully synchronous design, no latches, no gated clocks</li>
<li>Small hardware footprint and high operating frequency</li>
</ul>
<h3><a class="anchor" id="autotoc_md3"></a>
Design Principles</h3>
<ul>
<li>From zero to <em>hello_world</em>: Completely open source and documented.</li>
<li>Plain VHDL without technology-specific parts like attributes, macros or primitives.</li>
<li>Easy to use – working out of the box.</li>
<li>Clean synchronous design, no wacky combinatorial interfaces.</li>
<li>Be as small as possible – but with a reasonable size-performance trade-off.</li>
<li>Be as RISC-V-compliant as possible.</li>
<li>The processor has to fit in a Lattice iCE40 UltraPlus 5k low-power FPGA running at 22+ MHz.</li>
</ul>
<h3><a class="anchor" id="autotoc_md4"></a>
Status</h3>
<p>The processor is <a href="#FPGA-Implementation-Results">synthesizable</a> (tested on <em>real hardware</em> using Intel Quartus Prime, Xilinx Vivado and Lattice Radiant/Synplify Pro) and can successfully execute all the <a href="https://github.com/stnolting/neorv32/tree/master/sw/example">provided example programs</a> including the <a href="#CoreMark-Benchmark">CoreMark benchmark</a>.</p>
<p><b>RISC-V Architecture Tests</b>: The processor passes the official <code>rv32_m/C</code>, <code>rv32_m/I</code>, <code>rv32_m/M</code>, <code>rv32_m/privilege</code> and <code>rv32_m/Zifencei</code> <a href="https://github.com/riscv/riscv-arch-test">riscv-arch-test</a> tests. More information regarding the NEORV32 port of the riscv-arch-test test framework can be found in <a href="https://github.com/stnolting/neorv32/blob/master/riscv-arch-test/README.md"><code>riscv-arch-test/README.md</code></a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Project component   </th><th class="markdownTableHeadLeft">CI status    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a href="https://github.com/stnolting/neorv32">NEORV32 processor</a>   </td><td class="markdownTableBodyLeft"><a href="https://github.com/stnolting/neorv32/actions?query=workflow%3A%22Processor+Check%22"><img src="https://github.com/stnolting/neorv32/workflows/Processor%20Check/badge.svg" alt="Processor Check" style="pointer-events: none;" class="inline"/></a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a href="https://stnolting.github.io/neorv32/files.html">SW Framework Documentation (online @GH-pages)</a>   </td><td class="markdownTableBodyLeft"><a href="https://stnolting.github.io/neorv32/files.html"><img src="https://github.com/stnolting/neorv32/workflows/Deploy%20SW%20Framework%20Documentation%20to%20GitHub-Pages/badge.svg" alt="Doc@GitHub-pages" style="pointer-events: none;" class="inline"/></a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a href="https://github.com/stnolting/riscv-gcc-prebuilt">Pre-built toolchains</a>   </td><td class="markdownTableBodyLeft"><a href="https://github.com/stnolting/riscv-gcc-prebuilt/actions?query=workflow%3A%22Test+Toolchains%22"><img src="https://github.com/stnolting/riscv-gcc-prebuilt/workflows/Test%20Toolchains/badge.svg" alt="Test Toolchains" style="pointer-events: none;" class="inline"/></a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a href="https://github.com/stnolting/neorv32/blob/master/riscv-arch-test/README.md">RISC-V architecture test</a>   </td><td class="markdownTableBodyLeft"><a href="https://github.com/stnolting/neorv32/actions/workflows/riscv-arch-test.yml"><img src="https://github.com/stnolting/neorv32/actions/workflows/riscv-arch-test.yml/badge.svg" alt="riscv-arch-test" style="pointer-events: none;" class="inline"/></a>   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md5"></a>
Features</h2>
<p>The full-blown data sheet of the NEORV32 Processor and CPU is available as pdf file: <a href="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/NEORV32.pdf">:page_facing_up: NEORV32 data sheet</a>.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
NEORV32 Processor Features</h3>
<p><img src="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/figures/neorv32_processor.png" alt="neorv32 Overview" class="inline"/></p>
<p>The NEORV32 Processor provides a full-scale microcontroller-like SoC based on the NEORV32 CPU. The setup is highly customizable via the processor's top generics and already provides the following <em>optional</em> modules:</p>
<ul>
<li>processor-internal data and instruction memories (<b>DMEM</b> / <b>IMEM</b>) &amp; cache (<b>iCACHE</b>)</li>
<li>bootloader (<b>BOOTLDROM</b>) with UART console and automatic application boot from SPI flash option</li>
<li>machine system timer (<b>MTIME</b>), RISC-V-compatible</li>
<li>watchdog timer (<b>WDT</b>)</li>
<li>two independent universal asynchronous receivers and transmitters (<b>UART0</b> &amp; <b>UART1</b>) with optional hardware flow control (RTS/CTS)</li>
<li>8/16/24/32-bit serial peripheral interface controller (<b>SPI</b>) with 8 dedicated chip select lines</li>
<li>two wire serial interface controller (<b>TWI</b>), with optional clock-stretching, compatible to the I²C standard</li>
<li>general purpose parallel IO port (<b>GPIO</b>), 32xOut &amp; 32xIn, with pin-change interrupt</li>
<li>32-bit external bus interface, Wishbone b4 compatible (<b>WISHBONE</b>)</li>
<li>wrapper for <b>AXI4-Lite Master Interface</b> (see <a href="#AXI4-Connectivity">AXI Connectivity</a>)</li>
<li>PWM controller with 4 channels and 8-bit duty cycle resolution (<b>PWM</b>)</li>
<li>ring-oscillator-based true random number generator (<b>TRNG</b>)</li>
<li>custom functions subsystem (<b>CFS</b>) for tightly-coupled custom co-processor extensions</li>
<li>numerically-controlled oscillator (<b>NCO</b>) with three independent channels</li>
<li>system configuration information memory to check hardware configuration by software (<b>SYSINFO</b>)</li>
</ul>
<h3><a class="anchor" id="autotoc_md7"></a>
NEORV32 CPU Features</h3>
<p>The NEORV32 CPU implements the <a href="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/riscv-spec.pdf">official RISC-V specifications (2.2)</a> including a subset of the <a href="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/riscv-spec.pdf">RISC-V privileged architecture specifications (1.12-draft)</a></p><ul>
<li>tested via the <a href="https://github.com/riscv/riscv-arch-test">official riscv-arch-test Test Framework</a> (see <a href="https://github.com/stnolting/neorv32/blob/master/riscv-arch-test/README.md"><code>riscv-arch-test/README</code></a>).</li>
</ul>
<p>More information regarding the CPU including a detailed list of the instruction set and the available CSRs can be found in the <a href="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/NEORV32.pdf">:page_facing_up: NEORV32 data sheet</a>.</p>
<h4><a class="anchor" id="autotoc_md8"></a>
General Features</h4>
<ul>
<li>Modified Harvard architecture (separate CPU interfaces for data and instructions; NEORV32 processor: Single processor-internal bus via I/D mux)</li>
<li>Two stages in-order pipeline (FETCH, EXECUTE); each stage uses a multi-cycle processing scheme</li>
<li>No hardware support of unaligned accesses - they will trigger an exception</li>
<li>BIG-ENDIAN byte-order, processor's external memory interface allows endianness configuration to connect to system with different endianness</li>
<li>All reserved or unimplemented instructions will raise an illegal instruction exception</li>
<li>Privilege levels: <code>machine</code> mode, <code>user</code> mode (if enabled via <code>U</code> extension)</li>
<li>Official <a href="https://github.com/riscv/riscv-isa-manual/blob/master/marchid.md">RISC-V open-source architecture ID</a></li>
</ul>
<h4><a class="anchor" id="autotoc_md9"></a>
&lt;tt&gt;A&lt;/tt&gt; - Atomic memory access extension</h4>
<ul>
<li>Supported instructions: <code>LR.W</code> (load-reservate) <code>SC.W</code> (store-conditional)</li>
</ul>
<h4><a class="anchor" id="autotoc_md10"></a>
&lt;tt&gt;B&lt;/tt&gt; - Bit manipulation instructions extension</h4>
<ul>
<li>:construction: <b>WORK-IN-PROGRESS</b> :construction:</li>
<li>:warning: The bit-manipulation extension has not been officially ratified yet!</li>
<li>Compatible to <a href="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/bitmanip-draft.pdf">v0.94-draft</a> of the bit manipulation spec</li>
<li>Support via intrisc library (see <a href="https://github.com/stnolting/neorv32/tree/master/sw/example/bit_manipulation"><code>sw/example/bit_manipulation</code></a>)</li>
<li><code>Zbb</code> base instruction set: <code>CLZ</code> <code>CTZ</code> <code>CPOP</code> <code>SEXT.B</code> <code>SEXT.H</code> <code>MIN[U]</code> <code>MAX[U]</code> <code>ANDN</code> <code>ORN</code> <code>XNOR</code> <code>ROL</code> <code>ROR[I]</code> <code>zext</code>(<em>pseudo-instruction</em> for <code>PACK rd, rs, zero</code>) <code>rev8</code>(<em>pseudo-instruction</em> for <code>GREVI rd, rs, -8</code>) <code>orc.b</code>(<em>pseudo-instruction</em> for <code>GORCI rd, rs, 7</code>)</li>
<li><code>Zbs</code> single-bit instructions: <code>SBSET[I]</code> <code>SBCLR[I]</code> <code>SBINV[I]</code> <code>SBEXT[I]</code></li>
</ul>
<h4><a class="anchor" id="autotoc_md11"></a>
&lt;tt&gt;C&lt;/tt&gt; - Compressed instructions extension</h4>
<ul>
<li>ALU instructions: <code>C.ADDI4SPN</code> <code>C.ADD[I]</code> <code>C.ADDI16SP</code> <code>C.LI</code> <code>C.LUI</code> <code>C.SLLI</code> <code>C.SRLI</code> <code>C.SRAI</code> <code>C.ANDI</code> <code>C.SUB</code> <code>C.XOR</code> <code>C.OR</code> <code>C.AND</code> <code>C.MV</code> <code>C.NOP</code></li>
<li>Jump and branch instructions: <code>C.J</code> <code>C.JAL</code> <code>C.JR</code> <code>C.JALR</code> <code>C.BEQZ</code> <code>C.BNEZ</code></li>
<li>Memory instructions: <code>C.LW</code> <code>C.SW</code> <code>C.LWSP</code> <code>C.SWSP</code></li>
<li>System instructions: <code>C.EBREAK</code> (requires <code>Zicsr</code> extension)</li>
<li>Floating-point instructions: <code>C.FLW</code> <code>C.FSW</code> <code>C.FLWSP</code> <code>C.FSWSP</code> (requires <code>F</code> extension)</li>
<li>Pseudo-instructions are not listed</li>
</ul>
<h4><a class="anchor" id="autotoc_md12"></a>
&lt;tt&gt;E&lt;/tt&gt; - Embedded CPU version extension</h4>
<ul>
<li>Reduced register file (only the 16 lowest registers are implemented)</li>
</ul>
<h4><a class="anchor" id="autotoc_md13"></a>
&lt;tt&gt;F&lt;/tt&gt; - Single-precision floating-point extension</h4>
<ul>
<li>:construction: <b>WORK-IN-PROGRESS</b> :construction:</li>
<li>:warning: the <code>F</code> extension is not operational yet!</li>
<li>:information_source: check out the <a href="https://github.com/stnolting/neorv32/projects/4">F-extension project board</a> for the current implementation state</li>
</ul>
<h4><a class="anchor" id="autotoc_md14"></a>
&lt;tt&gt;I&lt;/tt&gt; - Base integer instruction set</h4>
<ul>
<li>ALU instructions: <code>LUI</code> <code>AUIPC</code> <code>ADD[I]</code> <code>SLT[I][U]</code> <code>XOR[I]</code> <code>OR[I]</code> <code>AND[I]</code> <code>SLL[I]</code> <code>SRL[I]</code> <code>SRA[I]</code> <code>SUB</code></li>
<li>Jump and branch instructions: <code>JAL</code> <code>JALR</code> <code>BEQ</code> <code>BNE</code> <code>BLT</code> <code>BGE</code> <code>BLTU</code> <code>BGEU</code></li>
<li>Memory instructions: <code>LB</code> <code>LH</code> <code>LW</code> <code>LBU</code> <code>LHU</code> <code>SB</code> <code>SH</code> <code>SW</code></li>
<li>System instructions: <code>ECALL</code> <code>EBREAK</code> <code>FENCE</code></li>
<li>Pseudo-instructions are not listed</li>
</ul>
<h4><a class="anchor" id="autotoc_md15"></a>
&lt;tt&gt;M&lt;/tt&gt; - Integer multiplication and division hardware extension</h4>
<ul>
<li>Multiplication instructions: <code>MUL</code> <code>MULH</code> <code>MULHSU</code> <code>MULHU</code></li>
<li>Division instructions: <code>DIV</code> <code>DIVU</code> <code>REM</code> <code>REMU</code></li>
<li>By default, the multiplier and divider cores use an iterative bit-serial processing scheme</li>
<li>Multiplications can be mapped to DSPs via the <code>FAST_MUL_EN</code> generic to increase performance</li>
</ul>
<h4><a class="anchor" id="autotoc_md16"></a>
&lt;tt&gt;U&lt;/tt&gt; - Privileged architecture - User mode extension</h4>
<ul>
<li>Requires <code>Zicsr</code> extension</li>
<li>Privilege levels: <code>M</code> (machine mode) + less-privileged <code>U</code> (user mode)</li>
</ul>
<h4><a class="anchor" id="autotoc_md17"></a>
&lt;tt&gt;X&lt;/tt&gt; - NEORV32-specific CPU extensions</h4>
<ul>
<li>The NEORV32-specific extensions are always enabled and are indicated via the <code>X</code> bit set in the <code>misa</code> CSR.</li>
<li>16 <em>fast interrupt</em> request channels with according control/status bits in <code>mie</code> and <code>mip</code> and custom exception codes in <code>mcause</code></li>
<li><code>mzext</code> CSR to check for implemented <code>Z*</code> CPU extensions (like <code>Zifencei</code>)</li>
<li>All undefined/umimplemented/malformed/illegal instructions do raise an illegal instruction exception</li>
</ul>
<h4><a class="anchor" id="autotoc_md18"></a>
&lt;tt&gt;Zicsr&lt;/tt&gt; - Privileged architecture - CSR access extension</h4>
<ul>
<li>Privilege levels: <code>M-mode</code> (Machine mode)</li>
<li>CSR access instructions: <code>CSRRW[I]</code> <code>CSRRS[I]</code> <code>CSRRC[I]</code></li>
<li>System instructions: <code>MRET</code> <code>WFI</code></li>
<li>Pseudo-instructions are not listed</li>
<li>Counter CSRs: <code>[m]cycle[h]</code> <code>[m]instret[m]</code> <code>time[h]</code> <code>[m]hpmcounter*[h]</code>(3..31, configurable) <code>mcounteren</code> <code>mcountinhibit</code> <code>mhpmevent*</code>(3..31, configurable)</li>
<li>Machine CSRs: <code>mstatus[h]</code> <code>misa</code>(read-only!) <code>mie</code> <code>mtvec</code> <code>mscratch</code> <code>mepc</code> <code>mcause</code> <code>mtval</code> <code>mip</code> <code>mvendorid</code> <a href="https://github.com/riscv/riscv-isa-manual/blob/master/marchid.md"><code>marchid</code></a> <code>mimpid</code> <code>mhartid</code> <code>mzext</code>(custom)</li>
<li>Supported (sync.) exceptions (implementing the RISC-V specs):<ul>
<li>Misaligned instruction address</li>
<li>Instruction access fault (via timeout/error after unacknowledged bus access)</li>
<li>Illegal instruction</li>
<li>Breakpoint (via <code>ebreak</code> instruction)</li>
<li>Load address misaligned</li>
<li>Load access fault (via timeout/error after unacknowledged bus access)</li>
<li>Store address misaligned</li>
<li>Store access fault (via unacknowledged bus access after timeout)</li>
<li>Environment call from U-mode (via <code>ecall</code> instruction in user mode)</li>
<li>Environment call from M-mode (via <code>ecall</code> instruction in machine mode)</li>
</ul>
</li>
<li>Supported (async.) exceptions / interrupts:<ul>
<li>Machine timer interrupt <code>mti</code> (via processor's MTIME unit / external signal)</li>
<li>Machine software interrupt <code>msi</code> (via external signal)</li>
<li>Machine external interrupt <code>mei</code> (via external signal)</li>
<li>16 fast interrupt requests (custom extension), 6+1 available for custom usage</li>
</ul>
</li>
</ul>
<h4><a class="anchor" id="autotoc_md19"></a>
&lt;tt&gt;Zifencei&lt;/tt&gt; - Privileged architecture - Instruction stream synchronization extension</h4>
<ul>
<li>System instructions: <code>FENCE.I</code> (among others, used to clear and reload instruction cache)</li>
</ul>
<h4><a class="anchor" id="autotoc_md20"></a>
&lt;tt&gt;PMP&lt;/tt&gt; - Privileged architecture - Physical memory protection</h4>
<ul>
<li>Requires <code>Zicsr</code> extension</li>
<li>Configurable number of regions (0..63)</li>
<li>Additional machine CSRs: <code>pmpcfg*</code>(0..15) <code>pmpaddr*</code>(0..63)</li>
</ul>
<h4><a class="anchor" id="autotoc_md21"></a>
&lt;tt&gt;HPM&lt;/tt&gt; - Privileged architecture - Hardware performance monitors</h4>
<ul>
<li>Requires <code>Zicsr</code> extension</li>
<li>Configurable number of counters (0..29)</li>
<li>Additional machine CSRs: <code>mhpmevent*</code>(3..31) <code>[m]hpmcounter*[h]</code>(3..31)</li>
</ul>
<h3><a class="anchor" id="autotoc_md22"></a>
:warning: Non-RISC-V-Compatible Issues and Limitations</h3>
<ul>
<li>CPU and Processor are BIG-ENDIAN, but this should be no problem as the external memory bus interface provides big- and little-endian configurations</li>
<li><code>misa</code> CSR is read-only - no dynamic enabling/disabling of synthesized CPU extensions during runtime; for compatibility: write accesses (in m-mode) are ignored and do not cause an exception</li>
<li>The physical memory protection (<b>PMP</b>) only supports <code>NAPOT</code> mode yet and a minimal granularity of 8 bytes</li>
<li>The <code>A</code> extension only implements <code>lr.w</code> and <code>sc.w</code> instructions yet. However, these instructions are sufficient to emulate all further AMO operations</li>
<li>The <code>mcause</code> trap code <code>0x80000000</code> (originally reserved in the RISC-V specs) is used to indicate a hardware reset (as "non-maskable interrupt")</li>
<li>The bit manipulation extension is not yet officially ratified, but is expected to stay unchanged. There is no software support in the upstream GCC RISC-V port yet. However, an intrinsic library is provided to utilize the provided bit manipulation extension from C-language code (see <a href="https://github.com/stnolting/neorv32/tree/master/sw/example/bit_manipulation"><code>sw/example/bit_manipulation</code></a>). NEORV32's <code>B</code> extension is compatible to spec. version "0.94-draft".</li>
</ul>
<h2><a class="anchor" id="autotoc_md23"></a>
FPGA Implementation Results</h2>
<h3><a class="anchor" id="autotoc_md24"></a>
NEORV32 CPU</h3>
<p>This chapter shows exemplary implementation results of the NEORV32 CPU for an <b>Intel Cyclone IV EP4CE22F17C6N FPGA</b> on a DE0-nano board. The design was synthesized using <b>Intel Quartus Prime Lite 20.1</b> ("balanced implementation"). The timing information is derived from the Timing Analyzer / Slow 1200mV 0C Model. If not otherwise specified, the default configuration of the CPU's generics is assumed (e.g. no physical memory protection, no hardware performance monitors). No constraints were used at all.</p>
<p>Results generated for hardware version <a href="https://github.com/stnolting/neorv32/blob/master/CHANGELOG.md"><code>1.5.1.4</code></a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">CPU Configuration   </th><th class="markdownTableHeadCenter">LEs   </th><th class="markdownTableHeadCenter">FFs   </th><th class="markdownTableHeadCenter">Memory bits   </th><th class="markdownTableHeadCenter">DSPs   </th><th class="markdownTableHeadCenter">f_max    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>rv32i</code>   </td><td class="markdownTableBodyCenter">979   </td><td class="markdownTableBodyCenter">409   </td><td class="markdownTableBodyCenter">1024   </td><td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyCenter">123 MHz    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>rv32i</code> + <code>Zicsr</code>   </td><td class="markdownTableBodyCenter">1789   </td><td class="markdownTableBodyCenter">847   </td><td class="markdownTableBodyCenter">1024   </td><td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyCenter">122 MHz    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>rv32im</code> + <code>Zicsr</code>   </td><td class="markdownTableBodyCenter">2381   </td><td class="markdownTableBodyCenter">1125   </td><td class="markdownTableBodyCenter">1024   </td><td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyCenter">122 MHz    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>rv32imc</code> + <code>Zicsr</code>   </td><td class="markdownTableBodyCenter">2608   </td><td class="markdownTableBodyCenter">1140   </td><td class="markdownTableBodyCenter">1024   </td><td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyCenter">122 MHz    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>rv32imac</code> + <code>Zicsr</code>   </td><td class="markdownTableBodyCenter">2621   </td><td class="markdownTableBodyCenter">1144   </td><td class="markdownTableBodyCenter">1024   </td><td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyCenter">122 MHz    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>rv32imacb</code> + <code>Zicsr</code>   </td><td class="markdownTableBodyCenter">3013   </td><td class="markdownTableBodyCenter">1310   </td><td class="markdownTableBodyCenter">1024   </td><td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyCenter">122 MHz    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>rv32imacb</code> + <code>Zicsr</code> + <code>u</code>   </td><td class="markdownTableBodyCenter">3031   </td><td class="markdownTableBodyCenter">1313   </td><td class="markdownTableBodyCenter">1024   </td><td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyCenter">122 MHz    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>rv32imacb</code> + <code>Zicsr</code> + <code>u</code> + <code>Zifencei</code>   </td><td class="markdownTableBodyCenter">3050   </td><td class="markdownTableBodyCenter">1313   </td><td class="markdownTableBodyCenter">1024   </td><td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyCenter">116 MHz   </td></tr>
</table>
<p>Setups with enabled "embedded CPU extension" <code>E</code> show the same LUT and FF utilization and identical f_max as the according <code>I</code> configuration. However, the size of the register file is cut in half.</p>
<h3><a class="anchor" id="autotoc_md25"></a>
NEORV32 Processor-Internal Peripherals and Memories</h3>
<p>Results generated for hardware version <a href="https://github.com/stnolting/neorv32/blob/master/CHANGELOG.md"><code>1.5.1.4</code></a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Module   </th><th class="markdownTableHeadLeft">Description   </th><th class="markdownTableHeadRight">LEs   </th><th class="markdownTableHeadRight">FFs   </th><th class="markdownTableHeadRight">Memory bits   </th><th class="markdownTableHeadRight">DSPs    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">BOOT ROM   </td><td class="markdownTableBodyLeft">Bootloader ROM (default 4kB)   </td><td class="markdownTableBodyRight">3   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">32 768   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">BUSSWITCH   </td><td class="markdownTableBodyLeft">Bus mux for CPU instr. &amp; data interfaces   </td><td class="markdownTableBodyRight">65   </td><td class="markdownTableBodyRight">8   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">i-CACHE   </td><td class="markdownTableBodyLeft">Proc.-int. nstruction cache (default 1x4x64 bytes)   </td><td class="markdownTableBodyRight">234   </td><td class="markdownTableBodyRight">156   </td><td class="markdownTableBodyRight">8 192   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">CFS   </td><td class="markdownTableBodyLeft">Custom functions subsystem   </td><td class="markdownTableBodyRight">-   </td><td class="markdownTableBodyRight">-   </td><td class="markdownTableBodyRight">-   </td><td class="markdownTableBodyRight">-    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">DMEM   </td><td class="markdownTableBodyLeft">Processor-internal data memory (default 8kB)   </td><td class="markdownTableBodyRight">6   </td><td class="markdownTableBodyRight">2   </td><td class="markdownTableBodyRight">65 536   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">GPIO   </td><td class="markdownTableBodyLeft">General purpose input/output ports   </td><td class="markdownTableBodyRight">67   </td><td class="markdownTableBodyRight">65   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">IMEM   </td><td class="markdownTableBodyLeft">Processor-internal instruction memory (default 16kb)   </td><td class="markdownTableBodyRight">6   </td><td class="markdownTableBodyRight">2   </td><td class="markdownTableBodyRight">131 072   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">MTIME   </td><td class="markdownTableBodyLeft">Machine system timer   </td><td class="markdownTableBodyRight">274   </td><td class="markdownTableBodyRight">166   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">NCO   </td><td class="markdownTableBodyLeft">Numerically-controlled oscillator   </td><td class="markdownTableBodyRight">254   </td><td class="markdownTableBodyRight">226   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">PWM   </td><td class="markdownTableBodyLeft">Pulse-width modulation controller   </td><td class="markdownTableBodyRight">71   </td><td class="markdownTableBodyRight">69   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">SPI   </td><td class="markdownTableBodyLeft">Serial peripheral interface   </td><td class="markdownTableBodyRight">138   </td><td class="markdownTableBodyRight">124   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">SYSINFO   </td><td class="markdownTableBodyLeft">System configuration information memory   </td><td class="markdownTableBodyRight">11   </td><td class="markdownTableBodyRight">10   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">TRNG   </td><td class="markdownTableBodyLeft">True random number generator   </td><td class="markdownTableBodyRight">132   </td><td class="markdownTableBodyRight">105   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">TWI   </td><td class="markdownTableBodyLeft">Two-wire interface   </td><td class="markdownTableBodyRight">77   </td><td class="markdownTableBodyRight">46   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">UART0/1   </td><td class="markdownTableBodyLeft">Universal asynchronous receiver/transmitter 0/1   </td><td class="markdownTableBodyRight">176   </td><td class="markdownTableBodyRight">132   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">WDT   </td><td class="markdownTableBodyLeft">Watchdog timer   </td><td class="markdownTableBodyRight">60   </td><td class="markdownTableBodyRight">45   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">WISHBONE   </td><td class="markdownTableBodyLeft">External memory interface   </td><td class="markdownTableBodyRight">129   </td><td class="markdownTableBodyRight">104   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md26"></a>
NEORV32 Processor - Exemplary FPGA Setups</h3>
<p>Exemplary processor implementation results for different FPGA platforms. The processor setup uses <em>the default peripheral configuration</em> (like no <em>CFS</em> and no <em>TRNG</em>), no external memory interface and only internal instruction and data memories. IMEM uses 16kB and DMEM uses 8kB memory space. The setup's top entity connects most of the processor's <a href="https://github.com/stnolting/neorv32/blob/master/rtl/core/neorv32_top.vhd">top entity</a> signals to FPGA pins - except for the Wishbone bus and the interrupt signals. The "default" strategy of each toolchain is used.</p>
<p>Results generated for hardware version <a href="https://github.com/stnolting/neorv32/blob/master/CHANGELOG.md"><code>1.4.9.0</code></a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Vendor   </th><th class="markdownTableHeadLeft">FPGA   </th><th class="markdownTableHeadLeft">Board   </th><th class="markdownTableHeadLeft">Toolchain   </th><th class="markdownTableHeadLeft">CPU Configuration   </th><th class="markdownTableHeadLeft">LUT / LE   </th><th class="markdownTableHeadLeft">FF / REG   </th><th class="markdownTableHeadLeft">DSP   </th><th class="markdownTableHeadLeft">Memory Bits   </th><th class="markdownTableHeadLeft">BRAM / EBR   </th><th class="markdownTableHeadLeft">SPRAM   </th><th class="markdownTableHeadRight">Frequency    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Intel   </td><td class="markdownTableBodyLeft">Cyclone IV <code>EP4CE22F17C6N</code>   </td><td class="markdownTableBodyLeft">Terasic DE0-Nano   </td><td class="markdownTableBodyLeft">Quartus Prime Lite 20.1   </td><td class="markdownTableBodyLeft"><code>rv32imc</code> + <code>u</code> + <code>Zicsr</code> + <code>Zifencei</code>   </td><td class="markdownTableBodyLeft">3813 (17%)   </td><td class="markdownTableBodyLeft">1904 (8%)   </td><td class="markdownTableBodyLeft">0 (0%)   </td><td class="markdownTableBodyLeft">231424 (38%)   </td><td class="markdownTableBodyLeft">-   </td><td class="markdownTableBodyLeft">-   </td><td class="markdownTableBodyRight">119 MHz    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Lattice   </td><td class="markdownTableBodyLeft">iCE40 UltraPlus <code>iCE40UP5K-SG48I</code>   </td><td class="markdownTableBodyLeft">Upduino v2.0   </td><td class="markdownTableBodyLeft">Radiant 2.1 (Synplify Pro)   </td><td class="markdownTableBodyLeft"><code>rv32ic</code> + <code>u</code> + <code>Zicsr</code> + <code>Zifencei</code>   </td><td class="markdownTableBodyLeft">4397 (83%)   </td><td class="markdownTableBodyLeft">1679 (31%)   </td><td class="markdownTableBodyLeft">0 (0%)   </td><td class="markdownTableBodyLeft">-   </td><td class="markdownTableBodyLeft">12 (40%)   </td><td class="markdownTableBodyLeft">4 (100%)   </td><td class="markdownTableBodyRight"><em>c</em> 22.15 MHz    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Xilinx   </td><td class="markdownTableBodyLeft">Artix-7 <code>XC7A35TICSG324-1L</code>   </td><td class="markdownTableBodyLeft">Arty A7-35T   </td><td class="markdownTableBodyLeft">Vivado 2019.2   </td><td class="markdownTableBodyLeft"><code>rv32imc</code> + <code>u</code> + <code>Zicsr</code> + <code>Zifencei</code> + <code>PMP</code>   </td><td class="markdownTableBodyLeft">2465 (12%)   </td><td class="markdownTableBodyLeft">1912 (5%)   </td><td class="markdownTableBodyLeft">0 (0%)   </td><td class="markdownTableBodyLeft">-   </td><td class="markdownTableBodyLeft">8 (16%)   </td><td class="markdownTableBodyLeft">-   </td><td class="markdownTableBodyRight"><em>c</em> 100 MHz   </td></tr>
</table>
<p>**_Notes_**</p><ul>
<li>The Lattice iCE40 UltraPlus setup uses the FPGA's SPRAM memory primitives for the internal IMEM and DMEM (each 64kb). The FPGA-specific memory components can be found in <a href="https://github.com/stnolting/neorv32/blob/master/rtl/fpga_specific/lattice_ice40up"><code>rtl/fpga_specific</code></a>.</li>
<li>The clock frequencies marked with a "c" are constrained clocks. The remaining ones are <em>f_max</em> results from the place and route timing reports.</li>
<li>The Upduino and the Arty board have on-board SPI flash memories for storing the FPGA configuration. These device can also be used by the default NEORV32 bootloader to store and automatically boot an application program after reset (both tested successfully).</li>
<li>The setups with <code>PMP</code> implement 2 regions with a minimal granularity of 64kB.</li>
<li>No HPM counters are implemented.</li>
</ul>
<h2><a class="anchor" id="autotoc_md27"></a>
Performance</h2>
<h3><a class="anchor" id="autotoc_md28"></a>
CoreMark Benchmark</h3>
<p>The <a href="https://www.eembc.org/coremark">CoreMark CPU benchmark</a> was executed on the NEORV32 and is available in the <a href="https://github.com/stnolting/neorv32/blob/master/sw/example/coremark">sw/example/coremark</a> project folder. This benchmark tests the capabilities of a CPU itself rather than the functions provided by the whole system / SoC.</p>
<div class="fragment"><div class="line">**Configuration**</div>
<div class="line">Hardware:       32kB IMEM, 16kB DMEM, no caches, 100MHz clock</div>
<div class="line">CoreMark:       2000 iterations, MEM_METHOD is MEM_STACK</div>
<div class="line">Compiler:       RISCV32-GCC 10.1.0 (rv32i toolchain)</div>
<div class="line">Compiler flags: default, see makefile</div>
<div class="line">Peripherals:    UART for printing the results</div>
</div><!-- fragment --><p>Results generated for hardware version <a href="https://github.com/stnolting/neorv32/blob/master/CHANGELOG.md"><code>1.4.9.8</code></a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">CPU (including <code>Zicsr</code>)   </th><th class="markdownTableHeadCenter">Executable Size   </th><th class="markdownTableHeadCenter">Optimization   </th><th class="markdownTableHeadCenter">CoreMark Score   </th><th class="markdownTableHeadCenter">CoreMarks/MHz    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>rv32i</code>   </td><td class="markdownTableBodyCenter">28 756 bytes   </td><td class="markdownTableBodyCenter"><code>-O3</code>   </td><td class="markdownTableBodyCenter">36.36   </td><td class="markdownTableBodyCenter"><b>0.3636</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>rv32im</code>   </td><td class="markdownTableBodyCenter">27 516 bytes   </td><td class="markdownTableBodyCenter"><code>-O3</code>   </td><td class="markdownTableBodyCenter">68.97   </td><td class="markdownTableBodyCenter"><b>0.6897</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>rv32imc</code>   </td><td class="markdownTableBodyCenter">22 008 bytes   </td><td class="markdownTableBodyCenter"><code>-O3</code>   </td><td class="markdownTableBodyCenter">68.97   </td><td class="markdownTableBodyCenter"><b>0.6897</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>rv32imc</code> + <code>FAST_MUL_EN</code>   </td><td class="markdownTableBodyCenter">22 008 bytes   </td><td class="markdownTableBodyCenter"><code>-O3</code>   </td><td class="markdownTableBodyCenter">86.96   </td><td class="markdownTableBodyCenter"><b>0.8696</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>rv32imc</code> + <code>FAST_MUL_EN</code> + <code>FAST_SHIFT_EN</code>   </td><td class="markdownTableBodyCenter">22 008 bytes   </td><td class="markdownTableBodyCenter"><code>-O3</code>   </td><td class="markdownTableBodyCenter">90.91   </td><td class="markdownTableBodyCenter"><b>0.9091</b>   </td></tr>
</table>
<p>The <code>FAST_MUL_EN</code> configuration uses DSPs for the multiplier of the <code>M</code> extension (enabled via the <code>FAST_MUL_EN</code> generic). The <code>FAST_SHIFT_EN</code> configuration uses a barrel shifter for CPU shift operations (enabled via the <code>FAST_SHIFT_EN</code> generic).</p>
<p>When the <code>C</code> extension is enabled, branches to an unaligned uncompressed instruction require additional instruction fetch cycles.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
Instruction Cycles</h3>
<p>The NEORV32 CPU is based on a two-stages pipelined architecutre. Each stage uses a multi-cycle processing scheme. Hence, each instruction requires several clock cycles to execute (2 cycles for ALU operations, ..., 40 cycles for divisions). The average CPI (cycles per instruction) depends on the instruction mix of a specific applications and also on the available CPU extensions. <em>By default</em> the CPU-internal shifter (e.g. for the <code>SLL</code> instruction) as well as the multiplier and divider of the <code>M</code> extension use a bit-serial approach and require several cycles for completion.</p>
<p>The following table shows the performance results for successfully running 2000 CoreMark iterations, which reflects a pretty good "real-life" work load. The average CPI is computed by dividing the total number of required clock cycles (only the timed core to avoid distortion due to IO wait cycles; sampled via the <code>cycle[h]</code> CSRs) by the number of executed instructions (<code>instret[h]</code> CSRs). The executables were generated using optimization <code>-O3</code>.</p>
<p>Results generated for hardware version <a href="https://github.com/stnolting/neorv32/blob/master/CHANGELOG.md"><code>1.4.9.8</code></a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">CPU (including <code>Zicsr</code>)   </th><th class="markdownTableHeadRight">Required Clock Cycles   </th><th class="markdownTableHeadRight">Executed Instructions   </th><th class="markdownTableHeadCenter">Average CPI    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>rv32i</code>   </td><td class="markdownTableBodyRight">5 595 750 503   </td><td class="markdownTableBodyRight">1 466 028 607   </td><td class="markdownTableBodyCenter"><b>3.82</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>rv32im</code>   </td><td class="markdownTableBodyRight">2 966 086 503   </td><td class="markdownTableBodyRight">598 651 143   </td><td class="markdownTableBodyCenter"><b>4.95</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>rv32imc</code>   </td><td class="markdownTableBodyRight">2 981 786 734   </td><td class="markdownTableBodyRight">611 814 918   </td><td class="markdownTableBodyCenter"><b>4.87</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>rv32imc</code> + <code>FAST_MUL_EN</code>   </td><td class="markdownTableBodyRight">2 399 234 734   </td><td class="markdownTableBodyRight">611 814 918   </td><td class="markdownTableBodyCenter"><b>3.92</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>rv32imc</code> + <code>FAST_MUL_EN</code> + <code>FAST_SHIFT_EN</code>   </td><td class="markdownTableBodyRight">2 265 135 174   </td><td class="markdownTableBodyRight">611 814 948   </td><td class="markdownTableBodyCenter"><b>3.70</b>   </td></tr>
</table>
<p>The <code>FAST_MUL_EN</code> configuration uses DSPs for the multiplier of the <code>M</code> extension (enabled via the <code>FAST_MUL_EN</code> generic). The <code>FAST_SHIFT_EN</code> configuration uses a barrel shifter for CPU shift operations (enabled via the <code>FAST_SHIFT_EN</code> generic).</p>
<p>When the <code>C</code> extension is enabled branches to an unaligned uncompressed instruction require additional instruction fetch cycles.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Top Entities</h2>
<p>The top entity of the <b>NEORV32 Processor</b> (SoC) is <a href="https://github.com/stnolting/neorv32/blob/master/rtl/core/neorv32_top.vhd"><code>rtl/core/neorv32_top.vhd</code></a>, which provides a Wishbone b4-compatoible bus interface.</p>
<p>:information_source: It is recommended to use the processor setup even if you want to <b>use the CPU in stand-alone mode</b>. Simply disable all the processor-internal modules via the generics and you will get a "CPU wrapper" that already provides a minimal CPU environment and an external memory interface (like AXI4). This setup also allows to further use the default bootloader and software framework. From this base you can start building your own processor system.</p>
<p>Use the top's generics to configure the system according to your needs. Each generic is initilized with the default configuration. Detailed information regarding the interface signals and configuration generics can be found in the <a href="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/NEORV32.pdf">:page_facing_up: NEORV32 data sheet</a> (pdf).</p>
<p>All signals of the top entity are of type <em>std_ulogic</em> or <em>std_ulogic_vector</em>, respectively (except for the processor's TWI signals, which are of type <em>std_logic</em>). Leave all unused output ports unconnected and tie all unused input ports to zero.</p>
<p><b>Alternative top entities</b>, like the simplified <a href="#Create-a-new-Hardware-Project">"hello world" test setup</a> or CPU/Processor wrappers with resolved port signal types (i.e. <em>std_logic</em>), can be found in <a href="https://github.com/stnolting/neorv32/blob/master/rtl/top_templates"><code>rtl/top_templates</code></a>.</p>
<h3><a class="anchor" id="autotoc_md31"></a>
AXI4 Connectivity</h3>
<p>Via the <a href="https://github.com/stnolting/neorv32/blob/master/rtl/top_templates/neorv32_top_axi4lite.vhd"><code>rtl/top_templates/neorv32_top_axi4lite.vhd</code></a> wrapper the NEORV32 provides an <b>AXI4-Lite</b> compatible master interface. This wrapper instantiates the default <a href="https://github.com/stnolting/neorv32/blob/master/rtl/core/neorv32_top.vhd">NEORV32 processor top entitiy</a> and implements a Wishbone to AXI4-Lite bridge.</p>
<p>The AXI4-Lite interface has been tested using Xilinx Vivado 19.2 block designer:</p>
<p><img src="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/figures/neorv32_axi_soc.png" alt="AXI-SoC" class="inline"/></p>
<p>The processor was packed as custom IP using <code>neorv32_top_axi4lite.vhd</code> as top entity. The AXI interface is automatically detected by the packager. All remaining IO interfaces are available as custom signals. The configuration generics are available via the "customize IP" dialog. In the figure above the resulting IP block is named "neorv32_top_axi4lite_v1_0". *(Note: Use Syntheiss option "global" when generating the block design to maintain the internal TWI tri-state drivers.)*</p>
<p>The setup uses an AXI interconnect to attach two block RAMs to the processor. Since the processor in this example is configured <em>without</em> IMEM and DMEM, the attached block RAMs are used for storing instructions and data: the first RAM is used as instruction memory and is mapped to address <code>0x00000000 - 0x00003fff</code> (16kB), the second RAM is used as data memory and is mapped to address <code>0x80000000 - 0x80001fff</code> (8kB).</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Getting Started</h2>
<p>This overview is just a short excerpt from the <em>Let's Get It Started</em> section of the NEORV32 documentary:</p>
<p><a href="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/NEORV32.pdf">:page_facing_up: NEORV32 data sheet</a></p>
<h3><a class="anchor" id="autotoc_md33"></a>
1. Get the Toolchain</h3>
<p>At first you need a <b>RISC-V GCC toolchain</b>. You can either <a href="https://github.com/riscv/riscv-gnu-toolchain">download the sources</a> and build the toolchain by yourself, or you can download a prebuilt one and install it.</p>
<p>To build the toolchain by yourself, follow the official <a href="https://github.com/riscv/riscv-gnu-toolchain">build instructions</a>. Make sure to use the <code>ilp32</code> or <code>ilp32e</code> ABI.</p>
<p><b>Alternatively</b>, you can download a prebuilt toolchain. I have uploaded the toolchains I am using to GitHub. These toolchains were compiled on a 64-bit x86 Ubuntu 20.04 LTS (Ubuntu on Windows, actually). Download the toolchain of choice: <a href="https://github.com/stnolting/riscv-gcc-prebuilt">:octocat: github.com/stnolting/riscv-gcc-prebuilt</a></p>
<p>You can also use the toolchains provided by <a href="https://github.com/sifive/freedom-tools/releases">SiFive</a>. These are 64-bit toolchains that can also emit 32-bit RISC-V code. They were compiled for more sophisticated machines (<code>rv32imac</code>) so make sure the according NEORV32 hardware extensions are enabled.</p>
<p>:warning: Keep in mind that – for instance – a <code>rv32imc</code> toolchain only provides library code compiled with compressed and <code>mul</code>/<code>div</code> instructions! Hence, this code cannot be executed (without emulation) on an architecture without these extensions!</p>
<p>To check everything works fine, make sure <code>GNU Make</code> and a native <code>GCC</code> compiler are installed. Test the installation of the RISC-V toolchain by navigating to an <a href="https://github.com/stnolting/neorv32/tree/master/sw/example">example program project</a> like <code>sw/example/blink_led</code> and running: </p><pre class="fragment">neorv32/sw/example/blink_led$ make check
</pre><h3><a class="anchor" id="autotoc_md34"></a>
2. Download the NEORV32 Project</h3>
<p>Get the sources of the NEORV32 Processor project. The simplest way is using <code>git clone</code> (suggested for easy project updates via <code>git pull</code>): </p><pre class="fragment">$ git clone https://github.com/stnolting/neorv32.git
</pre><p> Alternatively, you can either download a specific <a href="https://github.com/stnolting/neorv32/releases">release</a> or get the most recent version of this project as <a href="https://github.com/stnolting/neorv32/archive/master.zip"><code>*.zip</code> file</a>.</p>
<h3><a class="anchor" id="autotoc_md35"></a>
3. Create a new FPGA Project</h3>
<p>Create a new project with your FPGA design tool of choice. Add all the <code>*.vhd</code> files from the <a href="https://github.com/stnolting/neorv32/blob/master/rtl"><code>rtl/core</code></a> folder to this project. Make sure to add these files to a <b>new design library</b> called <code>neorv32</code>.</p>
<p>You can either instantiate the <a href="https://github.com/stnolting/neorv32/blob/master/rtl/core/neorv32_top.vhd">processor's top entity</a> or one of its <a href="https://github.com/stnolting/neorv32/blob/master/rtl/top_templates">wrappers</a> in your own project. If you just want to try thing out, you can use the simple <a href="https://github.com/stnolting/neorv32/blob/master/rtl/top_templates/neorv32_test_setup.vhd"><b>test setup</b> (<code>rtl/top_templates/neorv32_test_setup.vhd</code>)</a> as top entity.</p>
<p><img src="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/figures/neorv32_test_setup.png" alt="neorv32 test setup" class="inline"/></p>
<p>This test setup instantiates the processor and implements most of the peripherals and some ISA extensions. Only the UART0 communications lines, clock, reset and some GPIO output signals are propagated as actual top entity interface signals. Basically, it is a FPGA version of a "hello world" example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">entity </span>neorv32_test_setup <span class="keywordflow">is</span></div>
<div class="line">  <span class="keywordflow">port</span> <span class="vhdlchar">(</span></div>
<div class="line"><span class="comment">    -- Global control --</span></div>
<div class="line">    <span class="vhdlchar">clk_i</span>       <span class="vhdlchar">:</span> <span class="keywordflow">in</span>  <span class="keywordtype">std_ulogic</span> <span class="vhdlchar">:=</span> <span class="vhdlchar">&#39;</span><span class="vhdllogic"></span><span class="vhdllogic">0</span><span class="vhdlchar">&#39;</span>;<span class="comment"> -- global clock, rising edge</span></div>
<div class="line">    <span class="vhdlchar">rstn_i</span>      <span class="vhdlchar">:</span> <span class="keywordflow">in</span>  <span class="keywordtype">std_ulogic</span> <span class="vhdlchar">:=</span> <span class="vhdlchar">&#39;</span><span class="vhdllogic"></span><span class="vhdllogic">0</span><span class="vhdlchar">&#39;</span>;<span class="comment"> -- global reset, low-active, async</span></div>
<div class="line"><span class="comment">    -- GPIO --</span></div>
<div class="line">    <span class="vhdlchar">gpio_o</span>      <span class="vhdlchar">:</span> <span class="keywordflow">out</span> <span class="keywordtype">std_ulogic_vector</span><span class="vhdlchar">(</span><span class="vhdllogic"></span><span class="vhdllogic">7</span> <span class="keywordflow">downto</span> <span class="vhdllogic"></span><span class="vhdllogic">0</span><span class="vhdlchar">)</span>;<span class="comment"> -- parallel output</span></div>
<div class="line"><span class="comment">    -- UART0 --</span></div>
<div class="line">    <span class="vhdlchar">uart0_txd_o</span> <span class="vhdlchar">:</span> <span class="keywordflow">out</span> <span class="keywordtype">std_ulogic</span>;<span class="comment">       -- UART0 send data</span></div>
<div class="line">    <span class="vhdlchar">uart0_rxd_i</span> <span class="vhdlchar">:</span> <span class="keywordflow">in</span>  <span class="keywordtype">std_ulogic</span> <span class="vhdlchar">:=</span> <span class="vhdlchar">&#39;</span><span class="vhdllogic"></span><span class="vhdllogic">0</span><span class="vhdlchar">&#39;</span><span class="comment"> -- UART0 receive data</span></div>
<div class="line">  <span class="vhdlchar">)</span>;</div>
<div class="line"><span class="keywordflow">end</span> neorv32_test_setup;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md36"></a>
4. Compile an Example Program</h3>
<p>The NEORV32 project includes several <a href="https://github.com/stnolting/neorv32/tree/master/sw/example">example program project</a> from which you can start your own application. There are example programs to check out the processor's peripheral like I2C or the true-random number generator. And yes, there is also a port of <a href="https://github.com/stnolting/neorv32/tree/master/sw/example/game_of_life">Conway's Game of Life</a> available! :wink:</p>
<p>Simply compile one of these projects using </p><pre class="fragment">neorv32/sw/example/blink_led$ make clean_all exe
</pre><p> This will create a NEORV32 <em>executable</em> <code>neorv32_exe.bin</code> in the same folder, which you can upload via the bootloader.</p>
<h3><a class="anchor" id="autotoc_md37"></a>
5. Upload the Executable via the Bootloader</h3>
<p>Connect your FPGA board via UART to your computer and open the according port to interface with the fancy NEORV32 bootloader. The bootloader uses the following default UART configuration:</p>
<ul>
<li>19200 Baud</li>
<li>8 data bits</li>
<li>1 stop bit</li>
<li>No parity bits</li>
<li>No transmission / flow control protocol (raw bytes only)</li>
<li>Newline on <code>\r\n</code> (carriage return &amp; newline) - also for sent data</li>
</ul>
<p>Use the bootloader console to upload the <code>neorv32_exe.bin</code> executable gerated during application compiling and <em>run</em> your application.</p>
<div class="fragment"><div class="line">&lt;&lt; NEORV32 Bootloader &gt;&gt;</div>
<div class="line"> </div>
<div class="line">BLDV: Nov  7 2020</div>
<div class="line">HWV:  0x01040606</div>
<div class="line">CLK:  0x0134FD90 Hz</div>
<div class="line">USER: 0x0001CE40</div>
<div class="line">MISA: 0x42801104</div>
<div class="line">PROC: 0x03FF0035</div>
<div class="line">IMEM: 0x00010000 bytes @ 0x00000000</div>
<div class="line">DMEM: 0x00010000 bytes @ 0x80000000</div>
<div class="line"> </div>
<div class="line">Autoboot in 8s. Press key to abort.</div>
<div class="line">Aborted.</div>
<div class="line"> </div>
<div class="line">Available CMDs:</div>
<div class="line"> h: Help</div>
<div class="line"> r: Restart</div>
<div class="line"> u: Upload</div>
<div class="line"> s: Store to flash</div>
<div class="line"> l: Load from flash</div>
<div class="line"> e: Execute</div>
<div class="line">CMD:&gt; u</div>
<div class="line">Awaiting neorv32_exe.bin... OK</div>
<div class="line">CMD:&gt; e</div>
<div class="line">Booting...</div>
<div class="line"> </div>
<div class="line">Blinking LED demo program</div>
</div><!-- fragment --><p>Going further: Take a look at the <em>Let's Get It Started!</em> chapter of the <a href="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/NEORV32.pdf">:page_facing_up: NEORV32 data sheet</a>.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
Contribute/Feedback/Questions</h2>
<p>I'm always thankful for help! So if you have any questions, bug reports, ideas or if you want to give any kind of feedback, feel free to <a href="https://github.com/stnolting/neorv32/issues">open a new issue</a>, start a new <a href="https://github.com/stnolting/neorv32/discussions">discussion on GitHub</a> or directly <a href="#" onclick="location.href='mai'+'lto:'+'stn'+'ol'+'tin'+'g@'+'gma'+'il'+'.co'+'m'; return false;">drop me a line</a>.</p>
<p>Here is a simple guide line if you'd like to contribute to this repository:</p>
<p>0. :star: this repository :wink:</p><ol type="1">
<li>Check out the project's <a href="https://github.com/stnolting/neorv32/tree/master/CODE_OF_CONDUCT.md">code of conduct</a></li>
<li><a href="https://github.com/stnolting/neorv32/fork">Fork</a> this repository and clone the fork</li>
<li>Create a feature branch in your fork: <code>git checkout -b awesome_new_feature_branch</code></li>
<li>Create a new remote for the upstream repo: <code>git remote add upstream <a href="https://github.com/stnolting/neorv32">https://github.com/stnolting/neorv32</a></code></li>
<li>Commit your modifications: <code>git commit -m "Awesome new feature!"</code></li>
<li>Push to the branch: <code>git push origin awesome_new_feature_branch</code></li>
<li>Create a new <a href="https://github.com/stnolting/neorv32/pulls">pull request</a></li>
</ol>
<h2><a class="anchor" id="autotoc_md39"></a>
Legal</h2>
<p>This project is released under the BSD 3-Clause license. No copyright infringement intended. Other implied or used projects might have different licensing - see their documentation to get more information.</p>
<h4><a class="anchor" id="autotoc_md40"></a>
Citing</h4>
<p>If you are using the NEORV32 or parts of the project in some kind of publication, please cite it as follows:</p>
<blockquote class="doxtable">
<p>S. Nolting, "The NEORV32 RISC-V Processor", github.com/stnolting/neorv32 </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md41"></a>
BSD 3-Clause License</h4>
<p>Copyright (c) 2021, Stephan Nolting. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h4><a class="anchor" id="autotoc_md42"></a>
Limitation of Liability for External Links</h4>
<p>Our website contains links to the websites of third parties ("external links"). As the content of these websites is not under our control, we cannot assume any liability for such external content. In all cases, the provider of information of the linked websites is liable for the content and accuracy of the information provided. At the point in time when the links were placed, no infringements of the law were recognisable to us. As soon as an infringement of the law becomes known to us, we will immediately remove the link in question.</p>
<h4><a class="anchor" id="autotoc_md43"></a>
Proprietary  Notice</h4>
<p>"Artix" and "Vivado" are trademarks of Xilinx Inc.</p>
<p>"Cyclone" and "Quartus Prime Lite" are trademarks of Intel Corporation.</p>
<p>"iCE40", "UltraPlus" and "Radiant" are trademarks of Lattice Semiconductor Corporation.</p>
<p>"AXI", "AXI4" and "AXI4-Lite" are trademarks of Arm Holdings plc.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Acknowledgements</h2>
<p><a href="https://riscv.org/"><img src="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/figures/riscv_logo.png" alt="RISC-V" class="inline"/></a></p>
<p><a href="https://riscv.org/">RISC-V</a> - Instruction Sets Want To Be Free!</p>
<p>Continous integration provided by <a href="https://github.com/features/actions">:octocat: GitHub Actions</a> and powered by <a href="https://github.com/ghdl/ghdl">GHDL</a>.</p>
<p><img src="https://raw.githubusercontent.com/stnolting/neorv32/master/docs/figures/oshw_logo.png" alt="Open Source Hardware Logo https://www.oshwa.org" class="inline"/></p>
<p>This project is not affiliated with or endorsed by the Open Source Initiative (<a href="https://www.oshwa.org">https://www.oshwa.org</a> / <a href="https://opensource.org">https://opensource.org</a>).</p>
<hr  />
<p>Made with :coffee: in Hannover, Germany :eu: </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
